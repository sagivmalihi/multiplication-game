<!DOCTYPE html>
<html dir="rtl" lang="he">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>专 专驻转拽转 驻</title>
  <style>
    /* ============================================
       CSS VARIABLES - Design System
       ============================================ */
    :root {
      /* Princess Arielle's Blue Theme */
      --arielle-blue-light: #7DD3FC;
      --arielle-blue-medium: #3B82F6;
      --arielle-blue-dark: #1E40AF;

      /* Magical Purples */
      --magic-purple-light: #C084FC;
      --magic-purple: #A855F7;
      --magic-purple-dark: #7C3AED;

      /* Success & Progress */
      --success-green: #10B981;
      --success-glow: #34D399;

      /* Gold & Royal */
      --gold: #FBBF24;
      --gold-light: #FCD34D;
      --gold-dark: #F59E0B;

      /* Pink Accents */
      --arielle-pink: #F472B6;
      --pink-light: #FBCFE8;

      /* Warning & Energy */
      --warning-yellow: #FBBF24;
      --warning-orange: #FB923C;
      --danger-soft: #F87171;

      /* UI Neutrals */
      --white: #FFFFFF;
      --cream: #FEF3C7;
      --gray-light: #F3F4F6;
      --gray-medium: #9CA3AF;
      --gray-dark: #374151;
      --shadow: rgba(0, 0, 0, 0.1);
      --shadow-strong: rgba(0, 0, 0, 0.25);

      /* Text Colors */
      --text-primary: #1F2937;
      --text-secondary: #6B7280;
      --text-on-dark: #FFFFFF;

      /* Chapter 1: Emerald Meadows */
      --chapter-1-primary: #10B981;
      --chapter-1-secondary: #34D399;
      --chapter-1-accent: #059669;
      --chapter-1-bg: #D1FAE5;

      /* Chapter 2: Whispering Woods */
      --chapter-2-primary: #166534;
      --chapter-2-secondary: #22C55E;
      --chapter-2-accent: #7C3AED;
      --chapter-2-bg: #DCFCE7;

      /* Chapter 3: Crystal Caves */
      --chapter-3-primary: #6366F1;
      --chapter-3-secondary: #818CF8;
      --chapter-3-accent: #7C3AED;
      --chapter-3-bg: #E0E7FF;

      /* Chapter 4: Floating Gardens */
      --chapter-4-primary: #38BDF8;
      --chapter-4-secondary: #7DD3FC;
      --chapter-4-accent: #0284C7;
      --chapter-4-bg: #E0F2FE;

      /* Chapter 5: Rainbow Falls */
      --chapter-5-primary: #FF6B6B;
      --chapter-5-secondary: #4ECDC4;
      --chapter-5-accent: #9B59B6;
      --chapter-5-bg: #F0F8FF;

      /* Chapter 6: Desert of Echoes */
      --chapter-6-primary: #F59E0B;
      --chapter-6-secondary: #FCD34D;
      --chapter-6-accent: #D97706;
      --chapter-6-bg: #FFFBEB;

      /* Chapter 7: Frozen Peaks */
      --chapter-7-primary: #60A5FA;
      --chapter-7-secondary: #BFDBFE;
      --chapter-7-accent: #1D4ED8;
      --chapter-7-bg: #EFF6FF;

      /* Chapter 8: Twilight Marsh */
      --chapter-8-primary: #8B5CF6;
      --chapter-8-secondary: #C4B5FD;
      --chapter-8-accent: #6D28D9;
      --chapter-8-bg: #EDE9FE;

      /* Chapter 9: Starlight Bridge */
      --chapter-9-primary: #1E3A5F;
      --chapter-9-secondary: #4A90D9;
      --chapter-9-accent: #C0C0C0;
      --chapter-9-bg: #0D1B2A;

      /* Chapter 10: Crystal Palace */
      --chapter-10-primary: #FFD700;
      --chapter-10-secondary: #FFFAF0;
      --chapter-10-accent: #DAA520;
      --chapter-10-bg: #FFF8DC;

      /* Font Sizes */
      --text-xs: 0.75rem;
      --text-sm: 0.875rem;
      --text-base: 1rem;
      --text-lg: 1.125rem;
      --text-xl: 1.25rem;
      --text-2xl: 1.5rem;
      --text-3xl: 1.875rem;
      --text-4xl: 2.25rem;
      --text-5xl: 3rem;

      /* Multiplication sizes */
      --problem-size: 2rem;
      --answer-size: 1.75rem;
    }

    /* ============================================
       BASE RESET & TYPOGRAPHY
       ============================================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Varela Round', 'Rubik', 'Heebo', -apple-system, BlinkMacSystemFont, sans-serif;
      direction: rtl;
      text-align: right;
      background: var(--chapter-1-bg);
      min-height: 100vh;
      overflow: hidden;
    }

    /* ============================================
       GAME CONTAINER
       ============================================ */
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .screen.active {
      display: flex;
    }

    /* ============================================
       TITLE SCREEN
       ============================================ */
    #title-screen {
      background: url('assets/images/backgrounds-hd/title-screen.webp') center/cover no-repeat;
    }

    @keyframes bg-shift {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    .title-content {
      text-align: center;
    }

    .game-title {
      font-size: var(--text-5xl);
      font-weight: 900;
      color: var(--arielle-blue-dark);
      text-shadow: 3px 3px 6px var(--shadow-strong), 0 0 30px var(--gold-light);
      margin-bottom: 20px;
      animation: title-float 3s ease-in-out infinite;
    }

    @keyframes title-float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    .subtitle {
      font-size: var(--text-2xl);
      color: var(--magic-purple-dark);
      margin-bottom: 40px;
    }

    /* ============================================
       CRYSTAL BUTTONS
       ============================================ */
    .btn-crystal {
      position: relative;
      padding: 16px 32px;
      font-family: inherit;
      font-size: var(--text-lg);
      font-weight: 700;
      color: var(--text-on-dark);
      background: linear-gradient(135deg, var(--arielle-blue-medium), var(--magic-purple));
      border: none;
      border-radius: 12px;
      box-shadow: 0 4px 0 var(--arielle-blue-dark), 0 6px 12px var(--shadow-strong);
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 200px;
      min-height: 50px;
      overflow: hidden;
    }

    .btn-crystal::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, transparent 0%, rgba(255,255,255,0.3) 45%, rgba(255,255,255,0.1) 50%, transparent 55%);
      pointer-events: none;
    }

    .btn-crystal::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 50%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
      animation: shimmer 3s infinite;
    }

    @keyframes shimmer {
      0% { left: -100%; }
      50%, 100% { left: 100%; }
    }

    .btn-crystal:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 0 var(--arielle-blue-dark), 0 8px 16px var(--shadow-strong);
    }

    .btn-crystal:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 var(--arielle-blue-dark), 0 3px 6px var(--shadow);
    }

    .btn-crystal-gold {
      background: linear-gradient(135deg, var(--gold), var(--gold-light));
      box-shadow: 0 4px 0 var(--gold-dark), 0 6px 12px var(--shadow-strong);
    }

    .btn-crystal-gold:hover {
      box-shadow: 0 6px 0 var(--gold-dark), 0 8px 16px var(--shadow-strong);
    }

    /* ============================================
       STORY SCREEN
       ============================================ */
    #story-screen {
      background: url('assets/images/backgrounds-hd/chapter1-meadow.webp') center center / cover no-repeat;
      position: relative;
    }

    #story-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.3) 100%);
      pointer-events: none;
    }

    .story-container {
      max-width: 800px;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      position: relative;
      z-index: 1;
    }

    .chapter-title {
      font-size: var(--text-3xl);
      font-weight: 700;
      color: var(--chapter-1-primary);
      text-shadow: 1px 1px 2px var(--shadow);
    }

    .speech-bubble {
      position: relative;
      background: var(--white);
      border: 4px solid var(--text-primary);
      border-radius: 24px;
      padding: 24px 32px;
      max-width: 600px;
      box-shadow: 0 4px 12px var(--shadow-strong);
    }

    .speech-bubble p {
      font-size: var(--text-2xl);
      line-height: 1.6;
      color: var(--text-primary);
    }

    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -20px;
      right: 60px;
      width: 0;
      height: 0;
      border-left: 20px solid transparent;
      border-right: 20px solid transparent;
      border-top: 20px solid var(--text-primary);
    }

    .speaker-name {
      position: absolute;
      top: -16px;
      right: 24px;
      background: var(--arielle-blue-medium);
      color: var(--text-on-dark);
      padding: 4px 16px;
      border-radius: 12px;
      font-size: var(--text-sm);
      font-weight: 700;
      border: 2px solid var(--text-primary);
    }

    .character-display {
      display: flex;
      gap: 40px;
      align-items: flex-end;
      margin-top: 20px;
    }

    /* ============================================
       BATTLE SCREEN
       ============================================ */
    #battle-screen {
      background: url('assets/images/backgrounds-hd/battle-arena.webp') center/cover no-repeat;
    }

    /* Chapter-specific backgrounds */
    #story-screen.chapter-2 {
      background: url('assets/images/backgrounds-hd/chapter2-forest.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-2 {
      background: url('assets/images/backgrounds-hd/chapter2-battle.webp') center/cover no-repeat;
    }

    /* Chapter complete backgrounds */
    #complete-screen.chapter-1 {
      background: url('assets/images/backgrounds-hd/chapter1-complete.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-2 {
      background: url('assets/images/backgrounds-hd/chapter2-complete.webp') center/cover no-repeat;
    }

    /* Chapter 3: Crystal Caves */
    #story-screen.chapter-3 {
      background: url('assets/images/backgrounds-hd/chapter3-caves.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-3 {
      background: url('assets/images/backgrounds-hd/chapter3-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-3 {
      background: url('assets/images/backgrounds-hd/chapter3-complete.webp') center/cover no-repeat;
    }

    /* Chapter 4: Floating Gardens */
    #story-screen.chapter-4 {
      background: url('assets/images/backgrounds-hd/chapter4-gardens.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-4 {
      background: url('assets/images/backgrounds-hd/chapter4-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-4 {
      background: url('assets/images/backgrounds-hd/chapter4-complete.webp') center/cover no-repeat;
    }

    /* Chapter 5: Rainbow Falls */
    #story-screen.chapter-5 {
      background: url('assets/images/backgrounds-hd/chapter5-falls.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-5 {
      background: url('assets/images/backgrounds-hd/chapter5-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-5 {
      background: url('assets/images/backgrounds-hd/chapter5-complete.webp') center/cover no-repeat;
    }

    /* Chapter 6: Desert of Echoes */
    #story-screen.chapter-6 {
      background: url('assets/images/backgrounds-hd/chapter6-desert.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-6 {
      background: url('assets/images/backgrounds-hd/chapter6-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-6 {
      background: url('assets/images/backgrounds-hd/chapter6-complete.webp') center/cover no-repeat;
    }

    /* Chapter 7: Frozen Peaks */
    #story-screen.chapter-7 {
      background: url('assets/images/backgrounds-hd/chapter7-frozen.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-7 {
      background: url('assets/images/backgrounds-hd/chapter7-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-7 {
      background: url('assets/images/backgrounds-hd/chapter7-complete.webp') center/cover no-repeat;
    }

    /* Chapter 8: Twilight Marsh */
    #story-screen.chapter-8 {
      background: url('assets/images/backgrounds-hd/chapter8-marsh.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-8 {
      background: url('assets/images/backgrounds-hd/chapter8-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-8 {
      background: url('assets/images/backgrounds-hd/chapter8-complete.webp') center/cover no-repeat;
    }

    /* Chapter 9: Starlight Bridge */
    #story-screen.chapter-9 {
      background: url('assets/images/backgrounds-hd/chapter9-starlight.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-9 {
      background: url('assets/images/backgrounds-hd/chapter9-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-9 {
      background: url('assets/images/backgrounds-hd/chapter9-complete.webp') center/cover no-repeat;
    }

    /* Chapter 10: Crystal Palace */
    #story-screen.chapter-10 {
      background: url('assets/images/backgrounds-hd/chapter10-palace.webp') center center / cover no-repeat;
    }

    #battle-screen.chapter-10 {
      background: url('assets/images/backgrounds-hd/chapter10-battle.webp') center/cover no-repeat;
    }

    #complete-screen.chapter-10 {
      background: url('assets/images/backgrounds-hd/chapter10-complete.webp') center/cover no-repeat;
    }

    .battle-container {
      width: 100%;
      max-width: 900px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .battle-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
    }

    .hp-bar-container {
      position: relative;
      width: 200px;
      height: 30px;
    }

    .hp-bar-background {
      width: 100%;
      height: 100%;
      background: linear-gradient(180deg, #1E3A8A, #0F172A);
      border: 3px solid var(--gold);
      border-radius: 15px;
      overflow: hidden;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.5), 0 4px 12px var(--shadow-strong);
    }

    .hp-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #1E40AF, #3B82F6, #60A5FA, #93C5FD);
      background-size: 200% 100%;
      animation: flame-flow 2s linear infinite;
      transition: width 0.5s ease-out;
    }

    @keyframes flame-flow {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    .hp-label {
      font-size: var(--text-sm);
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .timer-container {
      position: relative;
      width: 200px;
      height: 40px;
    }

    .timer-bar {
      width: 100%;
      height: 100%;
      background: var(--gray-light);
      border: 3px solid var(--gray-dark);
      border-radius: 20px;
      overflow: hidden;
      box-shadow: inset 0 2px 6px var(--shadow);
    }

    .timer-bar-fill {
      height: 100%;
      width: 100%;
      transition: width 0.1s linear, background 0.3s ease;
      box-shadow: inset 0 0 15px rgba(255,255,255,0.4);
    }

    .timer-safe { background: linear-gradient(90deg, var(--success-green), var(--success-glow)); }
    .timer-warning { background: linear-gradient(90deg, var(--warning-yellow), var(--warning-orange)); animation: timer-pulse 1s ease-in-out infinite; }
    .timer-critical { background: linear-gradient(90deg, var(--warning-orange), var(--danger-soft)); animation: timer-pulse 0.5s ease-in-out infinite; }

    @keyframes timer-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .timer-display {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Courier New', monospace;
      font-size: var(--text-xl);
      font-weight: 700;
      color: var(--text-primary);
    }

    .battle-arena {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 100%;
      padding: 20px;
    }

    .character-sprite {
      width: 150px;
      height: 200px;
      object-fit: contain;
      animation: character-idle 3s ease-in-out infinite;
    }

    .pip-sprite {
      width: 60px;
      height: 60px;
      object-fit: contain;
      animation: pip-float 2s ease-in-out infinite;
    }

    @keyframes pip-float {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-6px) scale(1.05); }
    }

    .battle-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .battle-container {
      position: relative;
      z-index: 1;
    }

    @keyframes character-idle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-8px); }
    }

    .monster-sprite {
      width: 150px;
      height: 150px;
      animation: monster-idle 2s ease-in-out infinite;
    }

    @keyframes monster-idle {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-5px) scale(1.02); }
    }

    .monster-hit {
      animation: monster-shake 0.3s ease-out;
      filter: brightness(1.5);
    }

    @keyframes monster-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px) rotate(-5deg); }
      75% { transform: translateX(8px) rotate(5deg); }
    }

    .problem-display {
      background: var(--white);
      border: 4px solid var(--arielle-blue-medium);
      border-radius: 16px;
      padding: 20px 40px;
      font-family: 'Courier New', monospace;
      font-size: var(--problem-size);
      font-weight: 700;
      color: var(--text-primary);
      direction: ltr;
      text-align: center;
      box-shadow: 0 4px 12px var(--shadow-strong);
    }

    .answers-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      max-width: 400px;
    }

    .answer-option {
      position: relative;
      width: 120px;
      height: 80px;
      font-family: 'Courier New', monospace;
      font-size: var(--answer-size);
      font-weight: 700;
      color: var(--text-primary);
      background: var(--white);
      border: 4px solid var(--arielle-blue-medium);
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 4px 0 var(--arielle-blue-dark), 0 6px 12px var(--shadow);
    }

    .answer-option:hover {
      transform: translateY(-4px);
      border-color: var(--magic-purple);
      box-shadow: 0 8px 0 var(--magic-purple-dark), 0 10px 20px var(--shadow-strong);
    }

    .answer-option:active {
      transform: translateY(2px);
      box-shadow: 0 2px 0 var(--arielle-blue-dark), 0 3px 6px var(--shadow);
    }

    .answer-correct {
      background: linear-gradient(135deg, var(--success-glow), var(--success-green));
      border-color: var(--success-green);
      color: var(--text-on-dark);
      animation: answer-correct 0.6s ease-out;
    }

    @keyframes answer-correct {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .answer-wrong {
      animation: answer-wrong 0.5s ease-out;
    }

    @keyframes answer-wrong {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    /* Fill in blank input */
    .fill-blank-input {
      width: 100px;
      height: 60px;
      font-family: 'Courier New', monospace;
      font-size: var(--answer-size);
      font-weight: 700;
      text-align: center;
      border: 4px solid var(--magic-purple);
      border-radius: 12px;
      outline: none;
      direction: ltr;
    }

    .fill-blank-input:focus {
      border-color: var(--gold);
      box-shadow: 0 0 15px var(--gold-light);
    }

    /* Match pairs grid */
    .match-pairs-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      max-width: 500px;
    }

    .match-card {
      width: 100px;
      height: 70px;
      font-family: 'Courier New', monospace;
      font-size: var(--text-xl);
      font-weight: 700;
      background: var(--arielle-blue-medium);
      color: var(--text-on-dark);
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .match-card.flipped {
      background: var(--white);
      color: var(--text-primary);
    }

    .match-card.matched {
      background: var(--success-green);
      color: var(--text-on-dark);
      cursor: default;
    }

    /* ============================================
       VICTORY SCREEN
       ============================================ */
    #victory-screen {
      background: url('assets/images/backgrounds-hd/victory.webp') center/cover no-repeat;
      animation: victory-entrance 0.8s ease-out;
    }

    /* Chapter-specific victory backgrounds */
    #victory-screen.chapter-1 { background: url('assets/images/backgrounds-hd/chapter1-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-2 { background: url('assets/images/backgrounds-hd/chapter2-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-3 { background: url('assets/images/backgrounds-hd/chapter3-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-4 { background: url('assets/images/backgrounds-hd/chapter4-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-5 { background: url('assets/images/backgrounds-hd/chapter5-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-6 { background: url('assets/images/backgrounds-hd/chapter6-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-7 { background: url('assets/images/backgrounds-hd/chapter7-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-8 { background: url('assets/images/backgrounds-hd/chapter8-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-9 { background: url('assets/images/backgrounds-hd/chapter9-victory.webp') center/cover no-repeat; }
    #victory-screen.chapter-10 { background: url('assets/images/backgrounds-hd/chapter10-victory.webp') center/cover no-repeat; }

    @keyframes victory-entrance {
      0% { opacity: 0; transform: scale(0.8); }
      100% { opacity: 1; transform: scale(1); }
    }

    .victory-content {
      text-align: center;
    }

    .victory-message {
      font-size: var(--text-5xl);
      font-weight: 900;
      color: var(--text-on-dark);
      text-shadow: 0 0 20px var(--gold), 4px 4px 8px rgba(0,0,0,0.5);
      animation: victory-bounce 1s ease-out;
      margin-bottom: 30px;
    }

    @keyframes victory-bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0) scale(1); }
      40% { transform: translateY(-30px) scale(1.1); }
      60% { transform: translateY(-15px) scale(1.05); }
    }

    .victory-stats {
      background: rgba(255,255,255,0.9);
      border-radius: 16px;
      border: 3px solid var(--gold);
      padding: 20px 40px;
      margin-bottom: 30px;
    }

    .victory-stats p {
      font-size: var(--text-xl);
      color: var(--text-primary);
      margin: 10px 0;
    }

    /* Confetti */
    .confetti-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      pointer-events: none;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      top: -10px;
      animation: confetti-fall 3s linear forwards;
    }

    @keyframes confetti-fall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }

    /* ============================================
       RETRY SCREEN
       ============================================ */
    #retry-screen {
      background: linear-gradient(135deg, var(--pink-light), var(--cream));
    }

    .retry-content {
      text-align: center;
    }

    .retry-message {
      font-size: var(--text-4xl);
      font-weight: 700;
      color: var(--arielle-pink);
      margin-bottom: 20px;
    }

    .retry-encourage {
      font-size: var(--text-2xl);
      color: var(--text-primary);
      margin-bottom: 30px;
    }

    /* ============================================
       GAME COMPLETE SCREEN
       ============================================ */
    #complete-screen {
      background: linear-gradient(135deg, var(--gold-light), var(--magic-purple-light), var(--arielle-blue-light));
      animation: complete-bg 5s ease-in-out infinite alternate;
    }

    @keyframes complete-bg {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    .complete-content {
      text-align: center;
    }

    .complete-title {
      font-size: var(--text-5xl);
      font-weight: 900;
      color: var(--gold-dark);
      text-shadow: 0 0 30px var(--gold), 4px 4px 8px rgba(0,0,0,0.5);
      margin-bottom: 30px;
    }

    .complete-message {
      font-size: var(--text-2xl);
      color: var(--text-primary);
      margin-bottom: 20px;
    }

    /* ============================================
       SPEED BONUS INDICATOR
       ============================================ */
    .speed-bonus {
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: var(--text-4xl);
      font-weight: 900;
      z-index: 500;
      pointer-events: none;
      animation: speed-pop 0.8s ease-out forwards;
    }

    .speed-1x { color: var(--success-green); text-shadow: 0 0 10px var(--success-glow); }
    .speed-2x { color: var(--warning-orange); text-shadow: 0 0 20px var(--warning-orange); }
    .speed-3x { color: var(--gold); text-shadow: 0 0 30px var(--gold), 0 0 50px var(--gold-light); }

    @keyframes speed-pop {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
    }

    /* ============================================
       ENCOURAGEMENT MESSAGE
       ============================================ */
    .encourage-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      background: linear-gradient(135deg, var(--pink-light), var(--cream));
      border: 4px solid var(--arielle-pink);
      border-radius: 20px;
      font-size: var(--text-2xl);
      font-weight: 700;
      color: var(--text-primary);
      box-shadow: 0 8px 24px var(--shadow-strong);
      animation: encourage-bounce 0.6s ease-out;
      z-index: 998;
    }

    @keyframes encourage-bounce {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      60% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* ============================================
       AUDIO CONTROLS
       ============================================ */
    .audio-controls {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    }

    .audio-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 2px solid var(--gray-dark);
      background: var(--white);
      cursor: pointer;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .audio-btn.muted {
      background: var(--gray-light);
      opacity: 0.6;
    }

    /* ============================================
       RESPONSIVE
       ============================================ */
    @media (max-width: 768px) {
      .game-title { font-size: var(--text-4xl); }
      .speech-bubble p { font-size: var(--text-xl); }
      .answers-container { grid-template-columns: repeat(2, 1fr); }
      .answer-option { width: 100px; height: 70px; font-size: var(--text-xl); }
      .character-sprite { width: 100px; height: 140px; }
      .monster-sprite { width: 100px; height: 100px; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Audio Controls -->
    <div class="audio-controls">
      <button class="audio-btn" id="music-toggle" title="拽"></button>
      <button class="audio-btn" id="sfx-toggle" title="驻拽"></button>
    </div>

    <!-- Title Screen -->
    <div id="title-screen" class="screen active">
      <div class="title-content">
        <h1 class="game-title">专 专驻转拽转 驻</h1>
        <p class="subtitle">专驻转拽 拽住 转 专</p>
        <button class="btn-crystal btn-crystal-gold" id="start-btn">转 专驻转拽!</button>
        <div id="continue-container" style="margin-top: 20px; display: none;">
          <button class="btn-crystal" id="continue-btn">砖 砖拽</button>
        </div>
      </div>
    </div>

    <!-- Story Screen -->
    <div id="story-screen" class="screen">
      <div class="story-container">
        <h2 class="chapter-title" id="chapter-title">驻专拽 1:  专</h2>
        <div class="speech-bubble">
          <span class="speaker-name" id="speaker-name">驻驻</span>
          <p id="story-text">专  专驻转拽!</p>
        </div>
        <div class="character-display">
          <img id="story-arielle" class="character-sprite" src="assets/images/characters/arielle-happy.png" alt="专">
          <img id="story-pip" class="pip-sprite" src="assets/images/characters/pip.png" alt="驻驻">
        </div>
        <button class="btn-crystal" id="story-continue-btn">砖</button>
      </div>
    </div>

    <!-- Battle Screen -->
    <div id="battle-screen" class="screen">
      <div class="battle-background"></div>
      <div class="battle-container">
        <div class="battle-header">
          <div>
            <div class="hp-label"> 专</div>
            <div class="hp-bar-container">
              <div class="hp-bar-background">
                <div class="hp-bar-fill" id="player-hp-fill" style="width: 100%"></div>
              </div>
            </div>
          </div>
          <div class="timer-container">
            <div class="timer-bar">
              <div class="timer-bar-fill timer-safe" id="timer-fill"></div>
            </div>
            <div class="timer-display" id="timer-display">10</div>
          </div>
          <div>
            <div class="hp-label" id="monster-name">驻爪转</div>
            <div class="hp-bar-container">
              <div class="hp-bar-background">
                <div class="hp-bar-fill" id="monster-hp-fill" style="width: 100%"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="battle-arena">
          <img id="battle-arielle" class="character-sprite" src="assets/images/characters/arielle-happy.png" alt="专">
          <img id="battle-monster" class="monster-sprite" src="" alt="驻爪转">
        </div>

        <div class="problem-display" id="problem-display">5  3 = ?</div>

        <div id="minigame-area">
          <!-- Timed Selection (default) -->
          <div class="answers-container" id="answers-container"></div>
          <!-- Fill Blank -->
          <div id="fill-blank-area" style="display: none; text-align: center;">
            <input type="number" class="fill-blank-input" id="fill-blank-input" min="0" max="400">
            <button class="btn-crystal" id="submit-answer-btn" style="margin-top: 15px;">砖 转砖</button>
          </div>
          <!-- Match Pairs -->
          <div class="match-pairs-grid" id="match-pairs-grid" style="display: none;"></div>
        </div>
      </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="screen">
      <div class="confetti-container" id="confetti-container"></div>
      <div class="victory-content">
        <h1 class="victory-message" id="victory-message">爪!</h1>
        <div class="victory-stats">
          <p id="victory-damage">拽: <span>15</span></p>
          <p id="victory-time">: <span>5.2</span> 砖转</p>
        </div>
        <button class="btn-crystal btn-crystal-gold" id="victory-continue-btn">砖</button>
      </div>
    </div>

    <!-- Retry Screen -->
    <div id="retry-screen" class="screen">
      <div class="retry-content">
        <h1 class="retry-message">住 砖!</h1>
        <p class="retry-encourage" id="retry-encourage">转 专!  转转专!</p>
        <button class="btn-crystal" id="retry-btn">住 砖</button>
      </div>
    </div>

    <!-- Game Complete Screen -->
    <div id="complete-screen" class="screen">
      <div class="confetti-container" id="complete-confetti"></div>
      <div class="complete-content">
        <h1 class="complete-title"> !</h1>
        <p class="complete-message">住转 转 驻专拽 1!</p>
        <p class="complete-message">转 驻转 驻 转转!</p>
        <button class="btn-crystal btn-crystal-gold" id="play-again-btn">砖拽 砖</button>
      </div>
    </div>
  </div>
  <script>
    // ============================================
    // GAME STATE
    // ============================================
    const GameState = {
      currentScreen: 'title',
      chapter: 1,
      encounter: 0,
      playerHP: 100,
      playerMaxHP: 100,
      monsterHP: 0,
      monsterMaxHP: 5,
      score: 0,
      currentProblem: null,
      timerStartTime: 0,
      isPlaying: false,
      minigameType: 'selection', // selection, fillBlank, matchPairs
      isAnswering: false, // Guard against double-answering
      matchPairsState: {
        cards: [],
        flipped: [],
        matched: 0
      }
    };

    // ============================================
    // EVENT BUS
    // ============================================
    const Events = {
      listeners: {},
      on(event, callback) {
        if (!this.listeners[event]) this.listeners[event] = [];
        this.listeners[event].push(callback);
      },
      emit(event, data) {
        if (this.listeners[event]) {
          this.listeners[event].forEach(cb => cb(data));
        }
      }
    };


    // ============================================
    // AUDIO MANAGER (Web Audio API)
    // ============================================
    const AudioManager = {
      context: null,
      musicGain: null,
      sfxGain: null,
      settings: {
        musicEnabled: true,
        sfxEnabled: true,
        musicVolume: 0.4,
        sfxVolume: 0.7
      },
      currentMusic: null,
      // Background music elements
      bgmElements: {
        title: null,
        story: null,
        battle: null,
        storyChapter2: null,
        battleChapter2: null,
        storyChapter3: null,
        battleChapter3: null
      },
      currentBGM: null,

      init() {
        // Preload music immediately (doesn't require user interaction)
        this.preloadMusic();
        
        // Attempt to autoplay title music immediately
        if (document.getElementById('title-screen').classList.contains('active')) {
          this.attemptAutoplay();
        }
        
        // Fallback: if autoplay fails, start music on first user interaction
        document.addEventListener('click', () => {
          this.createContext();
          // If title music isn't playing yet, start it
          if (!this.currentBGM && document.getElementById('title-screen').classList.contains('active')) {
            this.playBGM('title');
          }
        }, { once: true });
      },
      
      attemptAutoplay() {
        // Try to autoplay title music immediately
        // Modern browsers may block this, but it's worth trying
        const titleAudio = this.bgmElements.title;
        if (titleAudio && this.settings.musicEnabled) {
          titleAudio.play()
            .then(() => {
              this.currentBGM = titleAudio;
              console.log('Title music autoplay successful');
            })
            .catch(e => {
              console.log('Autoplay blocked, waiting for user interaction:', e.message);
            });
        }
      },

      createContext() {
        if (this.context) return;
        this.context = new (window.AudioContext || window.webkitAudioContext)();

        this.musicGain = this.context.createGain();
        this.musicGain.gain.value = this.settings.musicVolume;
        this.musicGain.connect(this.context.destination);

        this.sfxGain = this.context.createGain();
        this.sfxGain.gain.value = this.settings.sfxVolume;
        this.sfxGain.connect(this.context.destination);
      },

      preloadMusic() {
        // Title theme - AI-generated via ElevenLabs
        this.bgmElements.title = new Audio('assets/audio/music/title-theme.mp3');
        this.bgmElements.title.loop = true;
        this.bgmElements.title.autoplay = true;
        this.bgmElements.title.volume = this.settings.musicVolume;
        
        this.bgmElements.story = new Audio('assets/audio/music/story-bgm.mp3');
        this.bgmElements.story.loop = true;
        this.bgmElements.story.volume = this.settings.musicVolume;

        this.bgmElements.battle = new Audio('assets/audio/music/battle-bgm.mp3');
        this.bgmElements.battle.loop = true;
        this.bgmElements.battle.volume = this.settings.musicVolume;

        // Chapter 2: Whispering Woods
        this.bgmElements.storyChapter2 = new Audio('assets/audio/music/chapter2-story.mp3');
        this.bgmElements.storyChapter2.loop = true;
        this.bgmElements.storyChapter2.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter2 = new Audio('assets/audio/music/chapter2-battle.mp3');
        this.bgmElements.battleChapter2.loop = true;
        this.bgmElements.battleChapter2.volume = this.settings.musicVolume;

        // Chapter 3: Crystal Caves
        this.bgmElements.storyChapter3 = new Audio('assets/audio/music/chapter3-story.mp3');
        this.bgmElements.storyChapter3.loop = true;
        this.bgmElements.storyChapter3.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter3 = new Audio('assets/audio/music/chapter3-battle.mp3');
        this.bgmElements.battleChapter3.loop = true;
        this.bgmElements.battleChapter3.volume = this.settings.musicVolume;

        // Chapter 1: Emerald Meadows
        this.bgmElements.storyChapter1 = new Audio('assets/audio/music/chapter1-story.mp3');
        this.bgmElements.storyChapter1.loop = true;
        this.bgmElements.storyChapter1.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter1 = new Audio('assets/audio/music/chapter1-battle.mp3');
        this.bgmElements.battleChapter1.loop = true;
        this.bgmElements.battleChapter1.volume = this.settings.musicVolume;

        // Chapter 4: Floating Gardens
        this.bgmElements.storyChapter4 = new Audio('assets/audio/music/chapter4-story.mp3');
        this.bgmElements.storyChapter4.loop = true;
        this.bgmElements.storyChapter4.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter4 = new Audio('assets/audio/music/chapter4-battle.mp3');
        this.bgmElements.battleChapter4.loop = true;
        this.bgmElements.battleChapter4.volume = this.settings.musicVolume;

        // Chapter 5: Rainbow Falls
        this.bgmElements.storyChapter5 = new Audio('assets/audio/music/chapter5-story.mp3');
        this.bgmElements.storyChapter5.loop = true;
        this.bgmElements.storyChapter5.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter5 = new Audio('assets/audio/music/chapter5-battle.mp3');
        this.bgmElements.battleChapter5.loop = true;
        this.bgmElements.battleChapter5.volume = this.settings.musicVolume;

        // Chapter 6: Desert of Echoes
        this.bgmElements.storyChapter6 = new Audio('assets/audio/music/chapter6-story.mp3');
        this.bgmElements.storyChapter6.loop = true;
        this.bgmElements.storyChapter6.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter6 = new Audio('assets/audio/music/chapter6-battle.mp3');
        this.bgmElements.battleChapter6.loop = true;
        this.bgmElements.battleChapter6.volume = this.settings.musicVolume;

        // Chapter 7: Frozen Peaks
        this.bgmElements.storyChapter7 = new Audio('assets/audio/music/chapter7-story.mp3');
        this.bgmElements.storyChapter7.loop = true;
        this.bgmElements.storyChapter7.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter7 = new Audio('assets/audio/music/chapter7-battle.mp3');
        this.bgmElements.battleChapter7.loop = true;
        this.bgmElements.battleChapter7.volume = this.settings.musicVolume;

        // Chapter 8: Twilight Marsh
        this.bgmElements.storyChapter8 = new Audio('assets/audio/music/chapter8-story.mp3');
        this.bgmElements.storyChapter8.loop = true;
        this.bgmElements.storyChapter8.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter8 = new Audio('assets/audio/music/chapter8-battle.mp3');
        this.bgmElements.battleChapter8.loop = true;
        this.bgmElements.battleChapter8.volume = this.settings.musicVolume;

        // Chapter 9: Starlight Bridge
        this.bgmElements.storyChapter9 = new Audio('assets/audio/music/chapter9-story.mp3');
        this.bgmElements.storyChapter9.loop = true;
        this.bgmElements.storyChapter9.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter9 = new Audio('assets/audio/music/chapter9-battle.mp3');
        this.bgmElements.battleChapter9.loop = true;
        this.bgmElements.battleChapter9.volume = this.settings.musicVolume;

        // Chapter 10: Crystal Palace
        this.bgmElements.storyChapter10 = new Audio('assets/audio/music/chapter10-story.mp3');
        this.bgmElements.storyChapter10.loop = true;
        this.bgmElements.storyChapter10.volume = this.settings.musicVolume;

        this.bgmElements.battleChapter10 = new Audio('assets/audio/music/chapter10-battle.mp3');
        this.bgmElements.battleChapter10.loop = true;
        this.bgmElements.battleChapter10.volume = this.settings.musicVolume;
      },

      playBGM(track, chapter = 1) {
        // Store what track should be playing (even if music is disabled)
        this.currentMusic = { track, chapter };

        if (!this.settings.musicEnabled) return;

        // Stop any existing music first
        this.stopBGM();

        // Determine which track to play (chapter-specific if available)
        let audioKey = track;
        if (chapter >= 1) {
          const chapterKey = `${track}Chapter${chapter}`;
          if (this.bgmElements[chapterKey]) {
            audioKey = chapterKey;
          }
        }

        const audio = this.bgmElements[audioKey];
        if (audio) {
          audio.currentTime = 0;
          audio.play().catch(e => console.log('BGM play blocked:', e));
          this.currentBGM = audio;
        }
      },

      stopBGM() {
        // Stop external audio
        if (this.currentBGM) {
          this.currentBGM.pause();
          this.currentBGM.currentTime = 0;
        }

        this.currentBGM = null;
      },

      playAudioFile(path) {
        if (!this.settings.sfxEnabled) return;
        const audio = new Audio(path);
        audio.volume = this.settings.sfxVolume;
        audio.play().catch(e => console.log('Audio play blocked:', e));
      },

      // Note frequencies for SFX
      notes: {
        C2: 65.41, C3: 130.81, C4: 261.63, C5: 523.25, C6: 1046.50,
        D4: 293.66, D5: 587.33, E4: 329.63, E5: 659.25,
        F4: 349.23, G4: 392.00, G5: 783.99, A4: 440.00, B4: 493.88
      },

      playCorrectAnswer(damage = 1) {
        if (!this.context || !this.settings.sfxEnabled) return;
        const now = this.context.currentTime;

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(this.sfxGain);

        if (damage >= 3) {
          // Epic arpeggio
          [this.notes.C5, this.notes.E5, this.notes.G5, this.notes.C6].forEach((note, i) => {
            osc.frequency.setValueAtTime(note, now + i * 0.1);
          });
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
          osc.start(now);
          osc.stop(now + 0.6);
        } else if (damage >= 2) {
          // Fast arpeggio
          [this.notes.C5, this.notes.E5, this.notes.G5].forEach((note, i) => {
            osc.frequency.setValueAtTime(note, now + i * 0.12);
          });
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
          osc.start(now);
          osc.stop(now + 0.5);
        } else {
          // Simple two-note
          osc.frequency.setValueAtTime(this.notes.C5, now);
          osc.frequency.setValueAtTime(this.notes.E5, now + 0.15);
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
          osc.start(now);
          osc.stop(now + 0.4);
        }
      },

      playWrongAnswer() {
        if (!this.context || !this.settings.sfxEnabled) return;
        const now = this.context.currentTime;

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'triangle';
        osc.connect(gain);
        gain.connect(this.sfxGain);

        // Gentle descending pattern (encouraging)
        osc.frequency.setValueAtTime(this.notes.E5, now);
        osc.frequency.setValueAtTime(this.notes.D5, now + 0.15);
        osc.frequency.setValueAtTime(this.notes.C5, now + 0.3);

        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

        osc.start(now);
        osc.stop(now + 0.5);
      },

      playMonsterHit() {
        if (!this.context || !this.settings.sfxEnabled) return;
        const now = this.context.currentTime;

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(this.sfxGain);

        osc.frequency.setValueAtTime(this.notes.C2, now);
        osc.frequency.exponentialRampToValueAtTime(this.notes.C2 * 0.5, now + 0.1);

        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

        osc.start(now);
        osc.stop(now + 0.2);
      },

      playVictory() {
        if (!this.context || !this.settings.sfxEnabled) return;
        const now = this.context.currentTime;

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(this.sfxGain);

        // Victory fanfare
        const notes = [this.notes.C5, this.notes.E5, this.notes.G5];
        notes.forEach((note, i) => {
          osc.frequency.setValueAtTime(note, now + i * 0.15);
        });

        gain.gain.setValueAtTime(0.3, now);
        gain.gain.setValueAtTime(0.3, now + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

        osc.start(now);
        osc.stop(now + 0.8);
      },

      playButtonClick() {
        if (!this.context || !this.settings.sfxEnabled) return;
        const now = this.context.currentTime;

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'square';
        osc.connect(gain);
        gain.connect(this.sfxGain);

        osc.frequency.setValueAtTime(this.notes.C5, now);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

        osc.start(now);
        osc.stop(now + 0.08);
      },

      playTimerTick() {
        if (!this.context || !this.settings.sfxEnabled) return;
        const now = this.context.currentTime;

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'triangle';
        osc.connect(gain);
        gain.connect(this.sfxGain);

        osc.frequency.setValueAtTime(this.notes.G4, now);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

        osc.start(now);
        osc.stop(now + 0.08);
      },

      toggleMusic() {
        this.settings.musicEnabled = !this.settings.musicEnabled;
        document.getElementById('music-toggle').classList.toggle('muted', !this.settings.musicEnabled);

        // Stop or resume BGM based on toggle
        if (!this.settings.musicEnabled) {
          this.stopBGM();
        } else if (this.currentMusic) {
          // Resume the track that was playing
          this.playBGM(this.currentMusic.track, this.currentMusic.chapter);
        }
      },

      toggleSFX() {
        this.settings.sfxEnabled = !this.settings.sfxEnabled;
        document.getElementById('sfx-toggle').classList.toggle('muted', !this.settings.sfxEnabled);
      }
    };

    // ============================================
    // SAVE MANAGER
    // ============================================
    const SaveManager = {
      SAVE_KEY: 'arielle_multiplication_save',

      save() {
        const data = {
          chapter: GameState.chapter,
          encounter: GameState.encounter,
          score: GameState.score,
          timestamp: Date.now()
        };
        localStorage.setItem(this.SAVE_KEY, JSON.stringify(data));
      },

      load() {
        const data = localStorage.getItem(this.SAVE_KEY);
        if (data) {
          return JSON.parse(data);
        }
        return null;
      },

      hasSave() {
        return localStorage.getItem(this.SAVE_KEY) !== null;
      },

      clearSave() {
        localStorage.removeItem(this.SAVE_KEY);
      }
    };

    // ============================================
    // STORY CONTENT (Hebrew)
    // ============================================
    const StoryContent = {
      chapter1: {
        title: '驻专拽 1:  专',
        intro: [
          { speaker: '住驻专', text: ' 转 砖注 砖 专, 拽专 砖 拽住...' },
          { speaker: '驻驻', text: '砖 专!  驻驻, 砖 住驻专!' },
          { speaker: '驻驻', text: '砖    -  驻!' },
          { speaker: '驻驻', text: ' 砖 住! 拽住  驻专 转 砖 拽住.' },
          { speaker: '驻驻', text: '专拽 转  专 转!  爪 专驻转拽!' },
        ],
        tutorial: [
          { speaker: '驻驻', text: '砖转专 驻爪转 转, 驻转专 转 转 驻  注专 !' },
          { speaker: '驻驻', text: ' 砖转注 专 转专, 转专 拽 转专 !' },
          { speaker: '驻驻', text: '专转 专 = 拽 1, 专 = 拽 2, 住驻专 专 = 拽 3!' },
        ],
        encounters: [
          { monster: 'chishubon', name: '砖', intro: ' ! 砖  住 转 专!' },
          { monster: 'kefulon', name: '驻', intro: '驻 拽 爪专 转 注专转!' },
          { monster: 'shigayon', name: '砖', intro: '砖 住专专!  注专 !' },
          { monster: 'chishubon', name: '砖', intro: '注 砖 !' },
          { monster: 'kefulon', name: '驻', intro: '驻 住祝 拽拽 !' },
          { monster: 'shigayon', name: '砖', intro: '砖 专  注专!' },
          { monster: 'chishubon', name: '砖', intro: '砖 专爪 !' },
          { monster: 'kefulon', name: '驻', intro: '驻 住 转专!' },
          { monster: 'shigayon', name: '砖', intro: '砖 拽 砖转注专!' },
          { monster: 'chishubon', name: '砖 专', intro: '驻爪转 专 砖 驻专拽!' },
        ],
        outro: [
          { speaker: '驻驻', text: '! 爪 转 砖 专砖!' },
          { speaker: '驻驻', text: '砖 专 专 拽!' },
          { speaker: '驻驻', text: '  专! 转 专 转转!' },
        ]
      },
      chapter2: {
        title: '驻专拽 2: 注专 砖',
        intro: [
          { speaker: '住驻专', text: '专 住转 注专 砖, 拽 拽住 砖 注爪  专...' },
          { speaker: '驻驻', text: '注专   驻注  ! 注爪 注 !' },
          { speaker: '驻驻', text: ' 砖祝 砖  注专 转  砖.  住 注专  爪 \'专砖!' },
          { speaker: '驻驻', text: '爪专 注专    .  爪专 转 注专转!' },
          { speaker: '驻驻', text: '注拽 注专 爪 注抓 专 .  砖专 注 砖 注专!' },
        ],
        encounters: [
          { monster: 'yinshouf-mevulbal', name: '砖祝 ', intro: '砖祝  砖 注 注祝,    专  注祝!' },
          { monster: 'ayal-mevulbal', name: ' ', intro: ' 拽 转拽   注专!' },
          { monster: 'ruach-etz-sevucha', name: '专 注抓 住', intro: '专 注抓 拽 住转 注驻 砖!' },
          { monster: 'yinshouf-mevulbal', name: '砖祝 ', intro: '注 砖祝  爪专 注专!' },
          { monster: 'ayal-mevulbal', name: ' ', intro: ' 住祝 驻砖 转 专 转!' },
          { monster: 'ruach-etz-sevucha', name: '专 注抓 住', intro: '专 注抓 注 转专 住!' },
          { monster: 'yinshouf-mevulbal', name: '砖祝 ', intro: '砖祝 砖砖 专爪 专 转!' },
          { monster: 'ayal-mevulbal', name: ' ', intro: ' 专 转注 注专驻!' },
          { monster: 'ruach-etz-sevucha', name: '专 注抓 住', intro: '专 注抓 专 爪专 注专!' },
          { monster: 'yinshouf-mevulbal', name: '砖祝 ', intro: '砖祝  砖专 注 专 注抓 专!' },
        ],
        outro: [
          { speaker: '驻驻', text: '! 注抓 专  转注专专!' },
          { speaker: '住驻专', text: '注抓 注转拽 驻转 转 注  专...' },
          { speaker: '驻驻', text: '砖 注专 爪!  专 专 注专 !' },
          { speaker: '驻驻', text: '注爪  专 砖! 注专 专 转!' },
        ]
      },
      chapter3: {
        title: '驻专拽 3: 注专转 ',
        intro: [
          { speaker: '住驻专', text: '转转 注专 砖, 驻转 砖  注 专 驻驻.' },
          { speaker: '驻驻', text: '! 注专转 ! 驻注   转 专,  注砖...' },
          { speaker: '住驻专', text: '砖 砖驻注 专 转 注专转 . 专拽 砖 注拽 砖专.' },
          { speaker: '专', text: ' 爪 转 专 砖?' },
          { speaker: '驻驻', text: ' 转砖  转拽 砖!  专 转 专!' }
        ],
        encounters: [
          { monster: 'chipushit-bedolach', name: '驻砖转-', intro: '驻砖转  转 住转 转 注专!  爪专 专!' },
          { monster: 'atalef-gavish', name: '注祝-砖', intro: '注祝 砖 砖 转 转拽专.     砖!' },
          { monster: 'golem-sela', name: '-住注', intro: ' 住注 注祝 注 专.    专转  转!' },
          { monster: 'chipushit-bedolach', name: '驻砖转-', intro: '注 驻砖转 ! 砖 砖  专.' },
          { monster: 'atalef-gavish', name: '注祝-砖', intro: '砖驻 砖 注驻 砖!  爪专 专  转注专专.' },
          { monster: 'golem-sela', name: '-住注', intro: ' 住注  住 转 住 拽砖 注转拽!' },
          { monster: 'chipushit-bedolach', name: '驻砖转-', intro: '驻砖转  拽  住专 砖.' },
          { monster: 'atalef-gavish', name: '注祝-砖', intro: '注祝 砖 驻拽. 注 注!' },
          { monster: 'golem-sela', name: '-住注', intro: '砖专 专 砖 拽砖 -  住注 注拽!' },
          { monster: 'golem-sela', name: '-住注', intro: ' 住注 专! 专 专 专 住!' }
        ],
        outro: [
          { speaker: '住驻专', text: ' 砖 注专 转注专专 ! 专 住  转 .' },
          { speaker: '驻驻', text: '住转! 注 !  砖 注拽!' },
          { speaker: '住驻专', text: '专 专 转 砖 住 专. 砖砖 砖 住驻!' },
          { speaker: '驻驻', text: '砖 专 砖 注... 砖!  专驻  !' }
        ]
      },
      chapter4: {
        title: '驻专拽 4:  专驻',
        intro: [
          { speaker: '住驻专', text: '专 爪 专 注爪专 砖转转. 驻 驻专砖  爪驻 砖!' },
          { speaker: '驻驻', text: '!  专驻!  拽住 砖爪驻  注!' },
          { speaker: '住驻专', text: ' 爪注 驻专 注  ,  砖专 砖专   砖专.' },
          { speaker: '驻驻', text: ' !  砖专 转 砖专 专! 爪专 转拽注 注  砖!' },
          { speaker: '住驻专', text: '专  -  爪专 驻转专 转 驻  转 砖 转 砖专.' }
        ],
        encounters: [
          { monster: 'shduon-anenim', name: '砖-注', intro: '砖 注 拽 爪祝  注 注 .  专 !' },
          { monster: 'piyat-gan', name: '驻转-', intro: '驻转  注 驻 爪注转 转拽注 注  拽.  爪专 注专!' },
          { monster: 'dag-meofef', name: '-注驻祝', intro: ' 注驻祝 注 拽砖拽砖 拽砖转 住转 注.  砖  注祝 砖专!' },
          { monster: 'shduon-anenim', name: '砖-注', intro: '注 砖 注!  住 转 砖专 注   爪.' },
          { monster: 'piyat-gan', name: '驻转-', intro: '驻转  砖转 注 驻专 注拽 .  专爪 专 转!' },
          { monster: 'dag-meofef', name: '-注驻祝', intro: '砖驻转  注驻驻!  砖 专 .' },
          { monster: 'shduon-anenim', name: '砖-注', intro: '砖 注 砖 砖 注 注.   转 .' },
          { monster: 'piyat-gan', name: '驻转-', intro: '驻转  住 驻专 驻专,   爪 驻!' },
          { monster: 'dag-meofef', name: '-注驻祝', intro: ' 注驻祝 !  砖专 注 砖专 专  注.' },
          { monster: 'shduon-anenim', name: '砖-注', intro: ' 砖!  拽 转 砖 砖  注专.' }
        ],
        outro: [
          { speaker: '住驻专', text: ' 砖专 专  砖!  爪驻 转专 砖.' },
          { speaker: '驻驻', text: '住转! 砖, 驻转  专拽  专!' },
          { speaker: '住驻专', text: '专 拽 转 砖 砖 -专. 专注 砖 住驻!' },
          { speaker: '驻驻', text: '转专 !  专 驻 爪注! 驻 拽砖转!' }
        ]
      },
      chapter5: {
        title: '驻专拽 5: 驻 拽砖转',
        intro: [
          { speaker: '住驻专', text: '专 驻驻 注 转  专驻 专  注拽 注爪 注 驻 专.' },
          { speaker: '驻驻', text: '驻   驻注 专  驻 !   爪注 拽砖转 专 ...' },
          { speaker: '住驻专', text: ' 注砖   驻专 . 爪注 注 专.' },
          { speaker: '驻驻', text: '注 爪注 住注! 注 砖 砖 爪 转 !  专 转 爪注!' }
        ],
        encounters: [
          { monster: 'gray-otter', name: '专 驻专', intro: '专 拽  砖拽 ,   专转 注爪 驻专.' },
          { monster: 'water-sprite', name: '专  ', intro: '专  专驻 专, 注 砖拽驻 专  爪注 砖.' },
          { monster: 'rainbow-fish', name: ' 拽砖转 住专 爪注', intro: ' 驻驻 砖 注, 住驻专 砖 驻注 爪注 注砖 驻专.' },
          { monster: 'gray-otter', name: '专 驻专', intro: '注 专 驻专 驻注, 住 砖拽   专.' },
          { monster: 'water-sprite', name: '专  ', intro: '专  住驻转 爪驻 , 拽拽 注专  专 砖.' },
          { monster: 'rainbow-fish', name: ' 拽砖转 住专 爪注', intro: ' 拽砖转 住祝 住转 专,  砖专  转 爪注.' },
          { monster: 'gray-otter', name: '专 驻专', intro: '专 砖砖转 驻 住注 拽, 转 注驻.' },
          { monster: 'water-sprite', name: '专  ', intro: '专   转专 驻注 专 驻, 注 转 专转.' },
          { monster: 'rainbow-fish', name: ' 拽砖转 住专 爪注', intro: ' 拽砖转  转专 砖 注专, 住驻专 专 专专 .' },
          { monster: 'water-sprite', name: '专  ', intro: '专  专 砖专 注 住 注专 专 驻.' }
        ],
        outro: [
          { speaker: '住驻专', text: '砖专 驻转专 转  专, 爪注 拽砖转 转 专 专 驻!' },
          { speaker: '驻驻', text: '转专! , 转, 爪, 专拽, , 住!  爪注 专!' },
          { speaker: '住驻专', text: '专 驻 专砖, 注专 住转专转, 砖 拽砖转 爪抓 专 砖转.' },
          { speaker: '驻驻', text: '砖 砖!  拽 爪注!    爪注转 注 注砖!' }
        ]
      },
      chapter6: {
        title: '驻专拽 6: 专 ',
        intro: [
          { speaker: '住驻专', text: '专 驻驻 注 转 驻 拽砖转 爪注 住 专 注爪 砖拽专 专 .' },
          { speaker: '驻驻', text: '专  !  爪   驻 转 注爪.  砖  住专...' },
          { speaker: '住驻专', text: ' 专  砖拽专! 拽  转 转,   转  .' },
          { speaker: '驻驻', text: ' 砖祝 砖 !  专  砖拽专.  爪专 专  转 转!' },
          { speaker: '住驻专', text: '爪专 专 - 爪驻专 , 砖注  专转 拽拽住 -    .' }
        ],
        encounters: [
          { monster: 'tsipor-hed', name: '爪驻专 ', intro: '爪驻专 拽 注 爪转 转 砖 注 住注 爪爪  砖拽专.' },
          { monster: 'shual-chol', name: '砖注 ', intro: '砖注 驻拽  注  注拽转 专抓 注,  .' },
          { monster: 'ruach-kaktus', name: '专 拽拽住', intro: '专 拽 爪专转 拽拽住 注 驻专 注 专砖 专驻 .' },
          { monster: 'tsipor-hed', name: '爪驻专 ', intro: '注 爪驻专  住转 转转 专转,    砖专  驻!' },
          { monster: 'shual-chol', name: '砖注 ', intro: '砖注  专 驻专  专祝, 驻砖 转 专 转.' },
          { monster: 'ruach-kaktus', name: '专 拽拽住', intro: '专 拽拽住  转专 砖专 注 住 拽 .' },
          { monster: 'tsipor-hed', name: '爪驻专 ', intro: '拽转 爪驻专  砖专  砖专  砖 住驻专 注专.' },
          { monster: 'shual-chol', name: '砖注 ', intro: '砖驻转 砖注  转住  ,  注  转.' },
          { monster: 'ruach-kaktus', name: '专 拽拽住', intro: '专 拽拽住 注转拽  专 拽住 拽拽 注专.' },
          { monster: 'tsipor-hed', name: '爪驻专 ', intro: '爪驻专  专 砖专 注 砖  .' }
        ],
        outro: [
          { speaker: '住驻专', text: '砖专 驻转专 转  专,  转 专 转 砖!' },
          { speaker: '驻驻', text: '转砖注!  专 转 转 注砖!  专 转 专 !' },
          { speaker: '住驻专', text: ' , 转 专 注转拽, 砖   爪抓 专 .' },
          { speaker: '驻驻', text: '砖砖 砖! 注 专注 爪 转 ! 拽 专 砖!' }
        ]
      },
      chapter7: {
        title: '驻专拽 7: 驻住转 拽专',
        intro: [
          { speaker: '住驻专', text: '专 驻驻 注  驻住转 拽专 - 专 住 砖 注 专转 拽专 爪爪.' },
          { speaker: '驻驻', text: '专专专! 拽专 驻!  砖砖 注,  拽驻 !' },
          { speaker: '住驻专', text: '爪专 砖 专注 拽专.  爪专  拽住!' },
          { speaker: '驻驻', text: ' 转专 驻 砖转驻转专 爪专 专 拽住 砖转 转!' },
          { speaker: '住驻专', text: '专转 爪驻 专拽 砖 砖专 转 驻住.' }
        ],
        encounters: [
          { monster: 'shduon-sheleg', name: '砖 砖', intro: '砖 砖 拽 专注 拽专  注专 拽驻!' },
          { monster: 'dov-kerach', name: ' 拽专', intro: ' 拽专 驻专转 砖 专注.  爪专 拽 !' },
          { monster: 'pingvin-zoef', name: '驻 注祝', intro: '驻 注祝 住 转 专.  专 砖 专专!' },
          { monster: 'shduon-sheleg', name: '砖 砖', intro: '注 砖 砖! 驻注  转拽注 注 爪拽 拽驻!' },
          { monster: 'dov-kerach', name: ' 拽专', intro: '砖驻转  拽专 爪专 注专 转!' },
          { monster: 'pingvin-zoef', name: '驻 注祝', intro: '砖 驻 注驻 转  拽专 转专!' },
          { monster: 'shduon-sheleg', name: '砖 砖', intro: '砖 砖 专拽 住 砖 拽专!' },
          { monster: 'dov-kerach', name: ' 拽专', intro: ' 拽专 注拽  砖  砖专 注 砖专 拽专!' },
          { monster: 'pingvin-zoef', name: '驻 注祝', intro: '驻 注祝 转专 砖专 注 砖注专 专 拽专!' },
          { monster: 'shduon-sheleg', name: '砖 砖', intro: '砖 砖 专 砖专 注 砖 拽专 驻住!' }
        ],
        outro: [
          { speaker: '住驻专', text: '砖 拽专 转 专 专 - 驻驻!' },
          { speaker: '驻驻', text: '注砖转 转 !  专! 转专   !' },
          { speaker: '住驻专', text: '爪专 拽专 专  专注.  专拽 砖 砖!' },
          { speaker: '驻驻', text: '驻住 驻砖专 专转 转 爪转  .  注  砖!' }
        ]
      },
      chapter8: {
        title: '驻专拽 8: 爪转 ',
        intro: [
          { speaker: '住驻专', text: '专 驻驻 专 驻住转 拽专 住 爪 住转专转 砖 转 .' },
          { speaker: '驻驻', text: '爪  专... 注专驻 住 住转专 转 专!  专砖 砖砖 砖拽 .' },
          { speaker: '住驻专', text: '专转 拽 专爪  注爪 注拽, 爪驻专注 专转 拽驻爪 注 注 砖砖.' },
          { speaker: '驻驻', text: ' 爪专 爪!  砖   专注. 砖祝 砖  专  转!' },
          { speaker: '住驻专', text: ' 驻专 转 注专驻 爪 转 砖 , 专 转爪专 驻转专 转 转.' }
        ],
        encounters: [
          { monster: 'or-toeh', name: '专 转注', intro: '专 拽 专 专祝 驻 专,   住  转   .' },
          { monster: 'tzfardea-arafel', name: '爪驻专注 注专驻', intro: '爪驻专注 住 注 注专驻 住 砖 注 注 砖砖, 拽专拽专转 转 转.' },
          { monster: 'drakon-bitza', name: '专拽 爪', intro: '专拽 拽  爪祝 , 住 专住住 注专驻 住  专拽 转注砖 .' },
          { monster: 'or-toeh', name: '专 转注', intro: '注 专 转注 驻注, 驻注 住  转 专 转  注拽.' },
          { monster: 'tzfardea-arafel', name: '爪驻专注 注专驻', intro: '爪驻专注 住驻转 拽驻爪 注专驻, 注 住转转  拽住 砖 .' },
          { monster: 'drakon-bitza', name: '专拽 爪', intro: '专拽 爪 砖 转 专 驻专 专转 爪 驻转注!' },
          { monster: 'or-toeh', name: '专 转注', intro: '砖砖 专转 转注 专拽 , 住  转 专 注 住驻专 砖注.' },
          { monster: 'tzfardea-arafel', name: '爪驻专注 注专驻', intro: '爪驻专注  转专 驻注 注专驻,  专转   砖 爪驻专注.' },
          { monster: 'drakon-bitza', name: '专拽 爪', intro: '专拽 拽 专 注 专! 砖砖 专拽 拽 爪驻 注.' },
          { monster: 'or-toeh', name: '专 转注', intro: '专 转注 专  转专 砖专 注 砖   拽.' }
        ],
        outro: [
          { speaker: '住驻专', text: '砖专 驻转专 转  专, 注专驻 住 转驻专 砖祝  拽 注 注 砖砖 注拽!' },
          { speaker: '驻驻', text: '转专! 砖 !  专 住 专  砖拽注  驻!' },
          { speaker: '住驻专', text: '爪专 爪 转 专拽 砖.  专   -  专 转 专!' },
          { speaker: '驻驻', text: '砖 砖! 专拽 注 砖! 转专 - 注专驻 驻转 砖祝 砖专  砖 !' }
        ]
      },
      chapter9: {
        title: '驻专拽 9: 砖专 ',
        intro: [
          { speaker: '住驻专', text: '专 驻驻 爪 爪转  专 驻 砖  - 砖专 注砖 专 !' },
          { speaker: '驻驻', text: '! 砖专 !   专  注爪  专 砖!' },
          { speaker: '住驻专', text: '转转 专 专转    驻 专转.  专拽 住.' },
          { speaker: '驻驻', text: ' 住转 - 砖 驻注专 砖专! 砖祝 砖  砖专 转. 爪专  !' },
          { speaker: '住驻专', text: ' 爪转 转 砖专 注 专, 专 转爪专 驻转专 转 驻  转 驻注专 专.' }
        ],
        encounters: [
          { monster: 'constellation-animal', name: '转 ', intro: ' 拽 注砖  专 专驻 驻 专, 拽 砖  .' },
          { monster: 'meteor-mouse', name: '注专 专', intro: '注专 拽 专 注  砖 砖 专 注 砖专,  注   专抓!' },
          { monster: 'comet-cat', name: '转 砖', intro: '转 驻驻 注  专 砖 拽专 专 爪祝 , 驻砖 转 专 转.' },
          { monster: 'constellation-animal', name: '转 ', intro: '注 转 ! 驻注 爪专转 专,  砖 转转拽 转专 .' },
          { monster: 'meteor-mouse', name: '注专 专', intro: '砖驻转 注专 专 专爪 注 注 砖专, 砖专 砖 砖!' },
          { monster: 'comet-cat', name: '转 砖', intro: '转 砖  转专 砖 注 驻注专 砖专, 专专 .' },
          { monster: 'constellation-animal', name: '转 ', intro: '转  爪专转  专拽  拽住转, 住 爪 转 专.' },
          { monster: 'meteor-mouse', name: '注专 专', intro: '注专 专  砖 注  拽,  砖砖 注专 .' },
          { monster: 'comet-cat', name: '转 砖', intro: '砖砖 转 砖 砖拽 , 转 砖转 专 驻驻.' },
          { monster: 'constellation-animal', name: '转 ', intro: '转  专 砖专 注 砖  砖专祝  专 拽!' }
        ],
        outro: [
          { speaker: '住驻专', text: '砖专 驻转专 转  专,  驻注专 砖专 转 专 !' },
          { speaker: '驻驻', text: '转专! 砖 !  专 住祝-    拽 砖!' },
          { speaker: '住驻专', text: '爪专  转 专拽 住 专, 爪专 爪注 砖 专 砖 转.' },
          { speaker: '驻驻', text: '转砖注 砖! 专拽 注 ! 转专 - 专 砖 砖 驻!   砖!' }
        ]
      },
      chapter10: {
        title: '驻专拽 10: 专 砖',
        intro: [
          { speaker: '住驻专', text: '专 注转 专转 砖砖 转 专转 转 专 砖 驻 - 转 转 转!' },
          { speaker: '驻驻', text: '注! 专 砖!  住转 -  专  专 转注专!' },
          { speaker: '住驻专', text: '专  , 专转   专, 专转 专  转 专.' },
          { speaker: '驻驻', text: ' 专注 , 专! 砖 专 ,   住 转!' }
        ],
        encounters: [
          { monster: 'royal-guard-golem', name: ' 砖专 转', intro: '  注拽 砖专 注 住.  砖 注   !' },
          { monster: 'palace-spirit', name: '专 专 转', intro: '专 拽 砖 专 爪驻 注专驻 砖 .' },
          { monster: 'knight-statue', name: '驻住 专 注专', intro: '驻住 砖 专 注转拽 转注专专 ,    专!' },
          { monster: 'royal-guard-golem', name: ' 砖专 转', intro: '注  砖专!    ,   专 注 .' },
          { monster: 'palace-spirit', name: '专 专 转', intro: '专 住驻转 砖 专 住  转 专.' },
          { monster: 'knight-statue', name: '驻住 专 注专', intro: '驻住 住祝 砖 专 拽 拽 拽专!' },
          { monster: 'royal-guard-golem', name: ' 砖专 转', intro: '砖砖  注 砖注专   转.' },
          { monster: 'palace-spirit', name: '专 专 转', intro: '专转 专 专拽转 注 砖 住.' },
          { monster: 'knight-statue', name: '驻住 专 注专', intro: '驻住 专 砖 专 拽  注专.' },
          { monster: 'balagan', name: ' 拽住', intro: ' 注爪 注  住 转.  专 注爪,  注祝.' }
        ],
        outro: [
          { speaker: '住驻专', text: '专 住  住 转.  注 砖, 拽祝 注专驻 砖 .' },
          { speaker: '', text: '注转 注 ? 祝    专 爪!' },
          { speaker: '专', text: ' 注砖转 转 , ?  驻专转 转 砖?' },
          { speaker: '', text: '...   注  爪转 驻.  爪拽 注.' },
          { speaker: '专', text: '   专  !    转!' },
          { speaker: '', text: '转... 转 转? 专   砖注砖转?' },
          { speaker: '专', text: '   .   砖转 住注 砖.' },
          { speaker: '住驻专', text: ' 住 转专 驻 驻砖 注专转 砖 专. 砖 拽 转砖 , 注 驻注专 驻转注.' },
          { speaker: '住驻专', text: '转 住 砖 驻  住专转, 砖 转专  专  砖 专!' },
          { speaker: '驻驻', text: ' , 专! 爪转 砖 转  专驻转拽! 转 驻转 驻 转转!' },
          { speaker: '住驻专', text: '注砖专转 砖 转 拽祝 转 专 专 拽砖转,    转 爪 砖 专!' }
        ]
      },
      encouragement: [
        '住 砖, 转 !',
        '注! 注 驻注!',
        ' 专, 砖 砖!',
        '转 专! 住 砖!',
        '转拽 转!',
      ],
      victoryMessages: [
        '!',
        '驻 !',
        ' !',
        '注!',
        '砖!',
      ],
      speedMessages: {
        1: ['!', '驻!', '!'],
        2: ['专!', '!', '拽!'],
        3: ['住驻专 !', '!', '驻!']
      }
    };

    // ============================================
    // RIDDLE GENERATOR
    // ============================================
    const RiddleGenerator = {
      // Difficulty progression: Ch1-3: tables 2-5, Ch4-6: tables 2-7, Ch7-9: tables 2-10, Ch10: tables 1-12
      generate(chapter = 1) {
        const maxTable = chapter === 10 ? 12 : Math.min(10, 2 + chapter);
        const a = Math.floor(Math.random() * maxTable) + 1;
        const b = Math.floor(Math.random() * 10) + 1;
        const missingFirst = Math.random() > 0.5;
        return {
          a, b,
          answer: a * b,
          display: `${a}  ${b} = ?`,
          fillBlankDisplay: missingFirst ? `?  ${b} = ${a * b}` : `${a}  ? = ${a * b}`,
          missingValue: missingFirst ? a : b
        };
      },

      generateOptions(correctAnswer) {
        const options = [correctAnswer];
        while (options.length < 4) {
          // Generate wrong answers close to correct
          const offset = Math.floor(Math.random() * 10) - 5;
          const wrong = Math.max(0, correctAnswer + offset);
          if (!options.includes(wrong) && wrong !== correctAnswer) {
            options.push(wrong);
          }
        }
        // Shuffle
        return options.sort(() => Math.random() - 0.5);
      },

      generateMatchPairs() {
        const pairs = [];
        const usedAnswers = new Set();
        let pairCount = 0;

        while (pairCount < 4) {  // 4 pairs = 8 cards
          const problem = this.generate();
          // Skip duplicate answers to avoid confusion
          if (usedAnswers.has(problem.answer)) {
            continue;
          }
          usedAnswers.add(problem.answer);

          pairs.push(
            { id: pairCount * 2, type: 'problem', value: `${problem.a}${problem.b}`, pairId: pairCount },
            { id: pairCount * 2 + 1, type: 'answer', value: problem.answer.toString(), pairId: pairCount }
          );
          pairCount++;
        }
        return pairs.sort(() => Math.random() - 0.5);
      }
    };

    // ============================================
    // TIMER SYSTEM
    // ============================================
    const TimerSystem = {
      duration: 10000, // 10 seconds for selection
      elapsed: 0,
      interval: null,
      lastTick: 0,

      start(duration) {
        this.duration = duration;
        this.elapsed = 0;
        this.lastTick = Date.now();
        GameState.timerStartTime = Date.now();

        this.interval = setInterval(() => this.update(), 100);
        this.updateDisplay();
      },

      update() {
        const now = Date.now();
        this.elapsed = now - GameState.timerStartTime;
        const remaining = Math.max(0, this.duration - this.elapsed);

        this.updateDisplay();

        // Timer tick sound in last 10 seconds
        const secondsLeft = Math.ceil(remaining / 1000);
        if (secondsLeft <= 10 && secondsLeft !== this.lastTick && secondsLeft > 0) {
          this.lastTick = secondsLeft;
          AudioManager.playTimerTick();
        }

        if (remaining <= 0) {
          this.stop();
          Events.emit('time_up');
        }
      },

      updateDisplay() {
        const remaining = Math.max(0, this.duration - this.elapsed);
        const percent = (remaining / this.duration) * 100;
        const seconds = Math.ceil(remaining / 1000);

        const fill = document.getElementById('timer-fill');
        const display = document.getElementById('timer-display');

        if (fill && display) {
          fill.style.width = percent + '%';
          display.textContent = seconds;

          // Update color class
          fill.className = 'timer-bar-fill';
          if (percent > 60) {
            fill.classList.add('timer-safe');
          } else if (percent > 30) {
            fill.classList.add('timer-warning');
          } else {
            fill.classList.add('timer-critical');
          }
        }
      },

      stop() {
        if (this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
      },

      getElapsed() {
        return this.elapsed;
      }
    };

    // ============================================
    // COMBAT SYSTEM
    // ============================================
    const CombatSystem = {
      calculateDamage(timeElapsed, maxTime) {
        const ratio = timeElapsed / maxTime;
        if (ratio < 0.3) return 3; // Super fast
        if (ratio < 0.6) return 2; // Fast
        return 1; // Normal
      },

      applyDamage(damage) {
        GameState.monsterHP = Math.max(0, GameState.monsterHP - damage);
        this.updateMonsterHP();

        // Show damage animation
        const monster = document.getElementById('battle-monster');
        monster.classList.add('monster-hit');
        setTimeout(() => monster.classList.remove('monster-hit'), 300);

        AudioManager.playMonsterHit();
        Events.emit('monster_hit', { damage, remainingHP: GameState.monsterHP });

        if (GameState.monsterHP <= 0) {
          Events.emit('monster_defeated');
        }
      },

      updateMonsterHP() {
        const fill = document.getElementById('monster-hp-fill');
        const percent = (GameState.monsterHP / GameState.monsterMaxHP) * 100;
        fill.style.width = percent + '%';
      },

      updatePlayerHP() {
        const fill = document.getElementById('player-hp-fill');
        const percent = (GameState.playerHP / GameState.playerMaxHP) * 100;
        fill.style.width = percent + '%';
      }
    };

    // ============================================
    // SCREEN MANAGER
    // ============================================
    const ScreenManager = {
      screens: ['title', 'story', 'battle', 'victory', 'retry', 'complete'],

      show(screenId) {
        this.screens.forEach(s => {
          const el = document.getElementById(s + '-screen');
          if (el) {
            el.classList.remove('active');
          }
        });

        const screen = document.getElementById(screenId + '-screen');
        if (screen) {
          screen.classList.add('active');
          GameState.currentScreen = screenId;
        }
      }
    };

    // ============================================
    // MINIGAME ENGINE
    // ============================================
    const MinigameEngine = {
      currentType: 'selection',

      startMinigame(type = 'selection') {
        this.currentType = type;
        GameState.minigameType = type;
        GameState.isAnswering = false; // Reset guard

        // Hide all minigame areas
        document.getElementById('answers-container').style.display = 'none';
        document.getElementById('fill-blank-area').style.display = 'none';
        document.getElementById('match-pairs-grid').style.display = 'none';

        switch (type) {
          case 'selection':
            this.startSelection();
            break;
          case 'fillBlank':
            this.startFillBlank();
            break;
          case 'matchPairs':
            this.startMatchPairs();
            break;
        }
      },

      startSelection() {
        document.getElementById('answers-container').style.display = 'grid';

        GameState.currentProblem = RiddleGenerator.generate(GameState.chapter);
        document.getElementById('problem-display').textContent = GameState.currentProblem.display;

        const options = RiddleGenerator.generateOptions(GameState.currentProblem.answer);
        const container = document.getElementById('answers-container');
        container.innerHTML = '';

        options.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'answer-option';
          btn.textContent = opt;
          btn.onclick = () => this.checkSelectionAnswer(opt, btn);
          container.appendChild(btn);
        });

        // Chapter 10 gets more time (15s instead of 10s)
        TimerSystem.start(GameState.chapter === 10 ? 15000 : 10000);
      },

      startFillBlank() {
        document.getElementById('fill-blank-area').style.display = 'block';

        GameState.currentProblem = RiddleGenerator.generate(GameState.chapter);
        document.getElementById('problem-display').textContent = GameState.currentProblem.fillBlankDisplay;

        const input = document.getElementById('fill-blank-input');
        input.value = '';
        input.focus();

        // Chapter 10 gets more time (20s instead of 15s)
        TimerSystem.start(GameState.chapter === 10 ? 20000 : 15000);
      },

      startMatchPairs() {
        document.getElementById('match-pairs-grid').style.display = 'grid';
        document.getElementById('problem-display').textContent = '转 转!';

        const cards = RiddleGenerator.generateMatchPairs();
        GameState.matchPairsState = { cards, flipped: [], matched: 0 };

        const grid = document.getElementById('match-pairs-grid');
        grid.innerHTML = '';

        cards.forEach(card => {
          const btn = document.createElement('button');
          btn.className = 'match-card';
          btn.dataset.id = card.id;
          btn.dataset.pairId = card.pairId;
          btn.dataset.value = card.value;
          btn.textContent = '?';
          btn.onclick = () => this.flipCard(btn, card);
          grid.appendChild(btn);
        });

        // Chapter 10 gets more time (60s instead of 45s)
        TimerSystem.start(GameState.chapter === 10 ? 60000 : 45000);
      },

      checkSelectionAnswer(answer, btn) {
        if (GameState.isAnswering) return; // Prevent double-answering
        GameState.isAnswering = true;
        TimerSystem.stop();

        if (answer === GameState.currentProblem.answer) {
          this.handleCorrect(btn);
        } else {
          this.handleWrong(btn);
        }
      },

      checkFillBlankAnswer() {
        if (GameState.isAnswering) return; // Prevent double-answering
        GameState.isAnswering = true;
        const input = document.getElementById('fill-blank-input');
        const answer = parseInt(input.value);

        TimerSystem.stop();

        if (answer === GameState.currentProblem.missingValue) {
          this.handleCorrect(input);
        } else {
          this.handleWrong(input);
        }
      },

      flipCard(btn, card) {
        if (btn.classList.contains('flipped') || btn.classList.contains('matched')) return;
        if (GameState.matchPairsState.flipped.length >= 2) return;

        btn.classList.add('flipped');
        btn.textContent = card.value;
        GameState.matchPairsState.flipped.push({ btn, card });

        if (GameState.matchPairsState.flipped.length === 2) {
          const [first, second] = GameState.matchPairsState.flipped;

          if (first.card.pairId === second.card.pairId) {
            // Match!
            setTimeout(() => {
              first.btn.classList.add('matched');
              second.btn.classList.add('matched');
              GameState.matchPairsState.matched++;
              AudioManager.playCorrectAnswer(1);

              if (GameState.matchPairsState.matched === 4) {  // 4 pairs matched = win
                TimerSystem.stop();
                const isChapter10 = GameState.chapter === 10;
                const maxTime = isChapter10 ? 60000 : 45000;
                const damage = CombatSystem.calculateDamage(TimerSystem.getElapsed(), maxTime);
                this.showSpeedBonus(damage);

                // Match pairs completion always defeats the monster (all-or-nothing minigame)
                GameState.monsterHP = 0;
                CombatSystem.updateMonsterHP();
                Events.emit('monster_defeated');
              }
            }, 300);
          } else {
            // No match
            setTimeout(() => {
              first.btn.classList.remove('flipped');
              second.btn.classList.remove('flipped');
              first.btn.textContent = '?';
              second.btn.textContent = '?';
            }, 800);
          }

          GameState.matchPairsState.flipped = [];
        }
      },

      handleCorrect(element) {
        element.classList?.add('answer-correct');

        const elapsed = TimerSystem.getElapsed();
        // Chapter 10 has extended timers
        const isChapter10 = GameState.chapter === 10;
        const maxTime = GameState.minigameType === 'fillBlank'
          ? (isChapter10 ? 20000 : 15000)
          : (isChapter10 ? 15000 : 10000);
        const damage = CombatSystem.calculateDamage(elapsed, maxTime);

        AudioManager.playCorrectAnswer(damage);
        CombatSystem.applyDamage(damage);
        this.showSpeedBonus(damage);

        // If monster still alive, start new problem immediately
        if (GameState.monsterHP > 0) {
          this.startMinigame(this.currentType);
        }
      },

      handleWrong(element) {
        element.classList?.add('answer-wrong');
        AudioManager.playWrongAnswer();
        this.showEncouragement();

        // Restart with new problem after delay
        setTimeout(() => {
          element.classList?.remove('answer-wrong');
          this.startMinigame(this.currentType);
        }, 1500);
      },

      showSpeedBonus(damage) {
        const bonus = document.createElement('div');
        bonus.className = `speed-bonus speed-${damage}x`;
        const messages = StoryContent.speedMessages[damage];
        bonus.textContent = `${damage} ${messages[Math.floor(Math.random() * messages.length)]}`;
        document.body.appendChild(bonus);
        setTimeout(() => bonus.remove(), 800);
      },

      showEncouragement() {
        const msg = document.createElement('div');
        msg.className = 'encourage-message';
        msg.textContent = StoryContent.encouragement[Math.floor(Math.random() * StoryContent.encouragement.length)];
        document.body.appendChild(msg);
        setTimeout(() => msg.remove(), 1500);
      }
    };

    // ============================================
    // GAME FLOW
    // ============================================
    const GameFlow = {
      storyIndex: 0,
      storyPhase: 'intro', // intro, tutorial, encounter, outro

      init() {
        // Check for saved game
        if (SaveManager.hasSave()) {
          document.getElementById('continue-container').style.display = 'block';
        }

        // Set up sprites
        this.setupSprites();

        // Event listeners
        this.setupEventListeners();

        // Initialize audio
        AudioManager.init();
      },

      setupSprites() {
        // Image-based sprites - already set via src attributes in HTML
        // This function now just ensures sprites are in default state
        const arielleSprites = document.querySelectorAll('#story-arielle, #battle-arielle');
        arielleSprites.forEach(el => {
          el.src = 'assets/images/characters/arielle-happy.png';
        });

        const pipSprite = document.getElementById('story-pip');
        if (pipSprite) {
          pipSprite.src = 'assets/images/characters/pip.png';
        }
      },

      setupEventListeners() {
        // Title screen
        document.getElementById('start-btn').onclick = () => {
          AudioManager.playButtonClick();
          this.startNewGame();
        };

        document.getElementById('continue-btn').onclick = () => {
          AudioManager.playButtonClick();
          this.continueGame();
        };

        // Story screen
        document.getElementById('story-continue-btn').onclick = () => {
          AudioManager.playButtonClick();
          this.advanceStory();
        };

        // Victory screen
        document.getElementById('victory-continue-btn').onclick = () => {
          AudioManager.playButtonClick();
          this.afterVictory();
        };

        // Retry screen
        document.getElementById('retry-btn').onclick = () => {
          AudioManager.playButtonClick();
          this.retryEncounter();
        };

        // Complete screen
        document.getElementById('play-again-btn').onclick = () => {
          AudioManager.playButtonClick();
          SaveManager.clearSave();
          this.startNewGame();
        };

        // Audio toggles
        document.getElementById('music-toggle').onclick = () => AudioManager.toggleMusic();
        document.getElementById('sfx-toggle').onclick = () => AudioManager.toggleSFX();

        // Fill blank submit
        document.getElementById('submit-answer-btn').onclick = () => {
          MinigameEngine.checkFillBlankAnswer();
        };

        document.getElementById('fill-blank-input').onkeypress = (e) => {
          if (e.key === 'Enter') MinigameEngine.checkFillBlankAnswer();
        };

        // Game events
        Events.on('monster_defeated', () => this.onMonsterDefeated());
        Events.on('time_up', () => this.onTimeUp());
      },

      startNewGame() {
        GameState.chapter = 1;
        GameState.encounter = 0;
        GameState.score = 0;
        GameState.playerHP = 100;

        this.storyPhase = 'intro';
        this.storyIndex = 0;

        ScreenManager.show('story');
        this.showStoryContent();
        AudioManager.playBGM('story', GameState.chapter);
      },

      continueGame() {
        const save = SaveManager.load();
        if (save) {
          GameState.chapter = save.chapter;
          GameState.encounter = save.encounter;
          GameState.score = save.score;
          GameState.playerHP = 100;

          // Update chapter title and screen classes for the loaded chapter
          const chapterKey = `chapter${GameState.chapter}`;
          const chapter = StoryContent[chapterKey];
          if (chapter) {
            document.getElementById('chapter-title').textContent = chapter.title;
            document.getElementById('story-screen').className = `screen chapter-${GameState.chapter}`;
            document.getElementById('battle-screen').className = `screen chapter-${GameState.chapter}`;
            document.getElementById('victory-screen').className = `screen chapter-${GameState.chapter}`;
          }

          this.storyPhase = 'encounter';
          this.startEncounter();
          AudioManager.playBGM('story', GameState.chapter);
        }
      },

      showStoryContent() {
        const chapterKey = `chapter${GameState.chapter}`;
        const chapter = StoryContent[chapterKey];

        if (!chapter) {
          console.error(`Chapter ${GameState.chapter} not found!`);
          return;
        }

        document.getElementById('chapter-title').textContent = chapter.title;

        // Add chapter class to screens for CSS targeting
        document.getElementById('story-screen').className = `screen active chapter-${GameState.chapter}`;
        document.getElementById('battle-screen').className = `screen chapter-${GameState.chapter}`;

        let content;
        switch (this.storyPhase) {
          case 'intro':
            content = chapter.intro;
            break;
          case 'tutorial':
            content = chapter.tutorial || []; // Tutorial only in chapter 1
            break;
          case 'outro':
            content = chapter.outro;
            break;
          default:
            content = [];
        }

        if (this.storyIndex < content.length) {
          const line = content[this.storyIndex];
          document.getElementById('speaker-name').textContent = line.speaker;
          document.getElementById('story-text').textContent = line.text;
        }
      },

      advanceStory() {
        const chapterKey = `chapter${GameState.chapter}`;
        const chapter = StoryContent[chapterKey];
        let content;

        switch (this.storyPhase) {
          case 'intro':
            content = chapter.intro;
            break;
          case 'tutorial':
            content = chapter.tutorial || [];
            break;
          case 'outro':
            content = chapter.outro;
            break;
          default:
            content = [];
        }

        this.storyIndex++;

        if (this.storyIndex >= content.length) {
          // Move to next phase
          if (this.storyPhase === 'intro') {
            // Only chapter 1 has tutorial
            if (GameState.chapter === 1 && chapter.tutorial && chapter.tutorial.length > 0) {
              this.storyPhase = 'tutorial';
              this.storyIndex = 0;
              this.showStoryContent();
            } else {
              this.storyPhase = 'encounter';
              this.startEncounter();
            }
          } else if (this.storyPhase === 'tutorial') {
            this.storyPhase = 'encounter';
            this.startEncounter();
          } else if (this.storyPhase === 'outro') {
            this.completeChapter();
          }
        } else {
          this.showStoryContent();
        }
      },

      startEncounter() {
        const chapterKey = `chapter${GameState.chapter}`;
        const chapter = StoryContent[chapterKey];
        const encounter = chapter.encounters[GameState.encounter];

        if (!encounter) {
          this.storyPhase = 'outro';
          this.storyIndex = 0;
          ScreenManager.show('story');
          this.showStoryContent();
          return;
        }

        // Show encounter intro
        document.getElementById('speaker-name').textContent = '驻驻';
        document.getElementById('story-text').textContent = encounter.intro;
        ScreenManager.show('story');

        // Update continue button to start battle
        const btn = document.getElementById('story-continue-btn');
        btn.textContent = '!';
        btn.onclick = () => {
          AudioManager.playButtonClick();
          btn.textContent = '砖';
          btn.onclick = () => {
            AudioManager.playButtonClick();
            this.advanceStory();
          };
          this.startBattle(encounter);
        };
      },

      startBattle(encounter) {
        ScreenManager.show('battle');
        // Add chapter class for chapter-specific backgrounds
        document.getElementById('battle-screen').className = `screen active chapter-${GameState.chapter}`;
        AudioManager.playBGM('battle', GameState.chapter);

        // Set up monster
        document.getElementById('monster-name').textContent = encounter.name;
        document.getElementById('battle-monster').src = `assets/images/monsters/${encounter.monster}.png`;

        // Set monster HP based on chapter
        GameState.monsterMaxHP = 5 + Math.floor(GameState.chapter / 2);
        GameState.monsterHP = GameState.monsterMaxHP;
        CombatSystem.updateMonsterHP();
        CombatSystem.updatePlayerHP();

        // Choose random minigame type
        const types = ['selection', 'selection', 'fillBlank', 'matchPairs'];
        const type = types[Math.floor(Math.random() * types.length)];

        MinigameEngine.startMinigame(type);
        GameState.isPlaying = true;
      },

      onMonsterDefeated() {
        TimerSystem.stop();
        GameState.isPlaying = false;

        // Save progress immediately (before player clicks continue)
        GameState.encounter++;
        SaveManager.save();

        AudioManager.stopBGM();
        AudioManager.playVictory();
        AudioManager.playAudioFile('assets/audio/sfx/victory-jingle.mp3');

        // Show victory screen with chapter-specific background
        document.getElementById('victory-screen').className = `screen chapter-${GameState.chapter}`;
        ScreenManager.show('victory');
        this.spawnConfetti();

        const messages = StoryContent.victoryMessages;
        document.getElementById('victory-message').textContent = messages[Math.floor(Math.random() * messages.length)];

        // Update arielle sprite to victory
        document.getElementById('battle-arielle').src = 'assets/images/characters/arielle-victory.png';
      },

      afterVictory() {
        // Restore normal sprite
        document.getElementById('battle-arielle').src = 'assets/images/characters/arielle-happy.png';

        // Progress already saved in onMonsterDefeated()
        AudioManager.playBGM('story', GameState.chapter);

        // Check if chapter complete
        if (GameState.encounter >= 10) {
          this.storyPhase = 'outro';
          this.storyIndex = 0;
          ScreenManager.show('story');
          this.showStoryContent();
        } else {
          this.startEncounter();
        }
      },

      onTimeUp() {
        GameState.isPlaying = false;

        // Take damage
        GameState.playerHP = Math.max(0, GameState.playerHP - 20);
        CombatSystem.updatePlayerHP();

        if (GameState.playerHP <= 0) {
          // Show retry screen
          ScreenManager.show('retry');
          document.getElementById('retry-encourage').textContent =
            StoryContent.encouragement[Math.floor(Math.random() * StoryContent.encouragement.length)];
        } else {
          // Continue with new problem
          MinigameEngine.startMinigame(GameState.minigameType);
        }
      },

      retryEncounter() {
        GameState.playerHP = 100;
        CombatSystem.updatePlayerHP();
        this.startEncounter();
      },

      completeChapter() {
        ScreenManager.show('complete');
        // Add chapter class for chapter-specific backgrounds (before chapter increments)
        document.getElementById('complete-screen').className = `screen active chapter-${GameState.chapter}`;
        this.spawnConfetti(document.getElementById('complete-confetti'));
        AudioManager.stopBGM();
        AudioManager.playAudioFile('assets/audio/sfx/chapter-complete.mp3');

        // Update complete message for current chapter
        const chapterKey = `chapter${GameState.chapter}`;
        const chapter = StoryContent[chapterKey];
        document.querySelector('.complete-message').textContent = `住转 转 ${chapter.title}!`;

        // Check if there's a next chapter
        const nextChapterKey = `chapter${GameState.chapter + 1}`;
        if (StoryContent[nextChapterKey]) {
          // Save progress to next chapter
          GameState.chapter++;
          GameState.encounter = 0;
          SaveManager.save();

          document.getElementById('play-again-btn').textContent = '砖 驻专拽 !';
          document.getElementById('play-again-btn').onclick = () => {
            AudioManager.playButtonClick();
            this.storyPhase = 'intro';
            this.storyIndex = 0;
            ScreenManager.show('story');
            this.showStoryContent();
            AudioManager.playBGM('story', GameState.chapter);
          };
        } else {
          // Final chapter complete - game finished!
          SaveManager.clearSave();

          // Special message for completing the entire game
          document.querySelector('.complete-message').textContent = ' ! 住转 转  专驻转拽!';
          document.querySelector('.complete-message').insertAdjacentHTML('afterend',
            '<p class="final-victory-text" style="color: var(--gold); font-size: 1.5rem; margin-top: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">转 驻转 驻 转转! </p>');

          document.getElementById('play-again-btn').textContent = '砖拽 砖 转';
          document.getElementById('play-again-btn').onclick = () => {
            AudioManager.playButtonClick();
            // Remove the final victory text when restarting
            const finalText = document.querySelector('.final-victory-text');
            if (finalText) finalText.remove();
            this.startNewGame();
          };
        }
      },

      spawnConfetti(container = document.getElementById('confetti-container')) {
        const colors = ['#FBBF24', '#F472B6', '#7DD3FC', '#10B981', '#A855F7'];

        for (let i = 0; i < 50; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.animationDelay = Math.random() * 2 + 's';
          confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
          container.appendChild(confetti);

          setTimeout(() => confetti.remove(), 5000);
        }
      }
    };

    // ============================================
    // EXPOSE FOR TESTING (Playwright E2E tests)
    // ============================================
    window.GameState = GameState;
    window.TimerSystem = TimerSystem;
    window.MinigameEngine = MinigameEngine;
    window.SaveManager = SaveManager;
    window.GameFlow = GameFlow;
    window.Events = Events;

    // ============================================
    // INITIALIZE GAME
    // ============================================
    document.addEventListener('DOMContentLoaded', () => {
      GameFlow.init();
    });
  </script>
</body>
</html>
